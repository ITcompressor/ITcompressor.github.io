<h4>Работа с данными</h4>
<h5><b>Числа</b></h5>
-На 32-битных системах практически нет смысла ставить для типа INTEGER свойство UNSIGNED, так как такие большие числа в php не поддерживаются.
<br>-На 64-битных системах, php поддерживает большие числа, вплоть до MySQL BIGINT со знаком.
<br>-Связанные таблицы («Foreign keys») должны иметь полное сходство по структуре ключей. 
Т.е. если у нас на одной таблице для поля указано «INTEGER UNSIGNED DEFAULT 0 NOT NULL» то и на другой должно быть указано аналогично
<br>-Для хранения булевых значений, нужно использовать TINYINT(1)
<br>-А деньги лучше хранить в DECIMAL(10, 2), где первое число обозначает количество всех знаков, включая запятую, 
а второе — количество знаков после запятой. Итого, у нас получится что DECIMAL(10,2) может сохранить 9999999,99
<br>
<h5><b>Строки</b></h5>
-В старых версиях (до 5.0.3) VARCHAR была ограничена 255 символами, но сейчас можно указывать до 65535 символов
<br>-Помните, что тип TEXT ограничен только 64 килобитами, поэтому что бы сохранять «Войну и Мир» пользуйтесь «LONGTEXT»
<br>-Самая правильная кодировка для вашей БД UTF8
<br>
<h5><b>Даты</b></h5>
-Не забывайте, что
<br>-DATE, TIME, DATETIME — выводятся в виде строк, поэтому поиск и сравнение дат происходит через преобразование
<br>-TIMESTAMP — хранится в виде UNIX_TIMESTAMP, и можно указать автоматически обновлять колонку
<br>-Сравнивая типы данных DATETIME и TIMESTAMP, не забывайте делать преобразование типов, например:
<pre>
SELECT * FROM table WHERE `datetime` = DATE(`timestamp`)
</pre>
<h5><b>Перечисления</b></h5>
-Для перечислений правильно использовать тип ENUM
<br>-Правильно пишется так: ENUM('мама', 'мыла', 'раму')
<br>-Можно ставить значение по-умолчанию, как и для любой строки
<br>-В базе поле с перечислением хранится как число, поэтому скорость работы — потрясающе высокая
<br>-Количество перечислений ~ 65 тысяч
<br>
<h5><b>Отладка</b></h5>
-Если запросы тормозят, то можно включить лог для медленных запросов в /etc/mysql/my.cnf
<br>-А потом оптимизировать запросы через EXPLAIN
<br>-И наблюдать за запросами удобно через программу mytop
<br>

<hr>

<h4>Общие факты</h4>
-Полезно под каждую базу на боевом сервере создавать своего пользователя
<br>-Кодировка базы может быть любой, если она UTF8
<br>-В большинстве случаев лучше использовать движок InnoDB
<br>-В php лучше забыть про сильно устаревшее расширение mysql и по-возможности использовать pdo или mysqli
<br>-Новую копию MySQL всегда можно настроить и оптимизировать
<br>-Без особой нужды не стоит открывать MySQL наружу. Вместо этого можно сделать проброс портов
<pre>
ssh -fNL LOCAL_PORT:localhost:3306 REMOTE_USER@REMOTE_HOST
</pre>

<hr>

<h2>Уровни изоляции</h2>
<h4><b>Read uncommitted (чтение незафиксированных данных)</b></h4>
Низший (первый) уровень изоляции. Он гарантирует только отсутствие потерянных обновлений[1]. Если несколько параллельных транзакций пытаются изменять 
одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определенное всем набором успешно выполненных транзакций. 
При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.
Типичный способ реализации данного уровня изоляции — блокировка данных на время выполнения команды изменения, что гарантирует, что команды изменения 
одних и тех же строк, запущенные параллельно, фактически выполнятся последовательно, и ни одно из изменений не потеряется. Транзакции, выполняющие только 
чтение, при данном уровне изоляции никогда не блокируются. 
<h4><b>Read committed (чтение фиксированных данных)</b></h4>
Большинство промышленных СУБД, в частности, Microsoft SQL Server, PostgreSQL и Oracle, по умолчанию используют именно этот уровень. 
На этом уровне обеспечивается защита от чернового, «грязного» чтения, тем не менее, в процессе работы одной транзакции другая может 
быть успешно завершена и сделанные ею изменения зафиксированы. В итоге первая транзакция будет работать с другим набором данных.
Реализация завершённого чтения может основываться на одном из двух подходов: блокировании или версионности. 
<p>
<b>Блокирование читаемых и изменяемых данных.</b>
Заключается в том, что пишущая транзакция блокирует изменяемые данные для читающих транзакций, работающих на уровне read committed или более высоком, 
до своего завершения, препятствуя, таким образом, «грязному» чтению, а данные, блокируемые читающей транзакцией, освобождаются сразу после завершения 
операции SELECT (таким образом, ситуация «неповторяющегося чтения» может возникать на данном уровне изоляции).
</p>
<p>
<b>Сохранение нескольких версий параллельно изменяемых строк.</b>
При каждом изменении строки СУБД создаёт новую версию этой строки, с которой продолжает работать изменившая данные транзакция, в то время как любой другой 
«читающей» транзакции возвращается последняя зафиксированная версия. Преимущество такого подхода в том, что он обеспечивает бо́льшую скорость, 
так как предотвращает блокировки. Однако он требует, по сравнению с первым, существенно бо́льшего расхода оперативной памяти, которая тратится на хранение 
версий строк. Кроме того, при параллельном изменении данных несколькими транзакциями может создаться ситуация, когда несколько параллельных транзакций 
произведут несогласованные изменения одних и тех же данных (поскольку блокировки отсутствуют, ничто не помешает это сделать). Тогда та транзакция, 
которая зафиксируется первой, сохранит свои изменения в основной БД, а остальные параллельные транзакции окажется невозможно зафиксировать 
(так как это приведёт к потере обновления первой транзакции). Единственное, что может в такой ситуации СУБД — это откатить остальные транзакции и выдать 
сообщение об ошибке «Запись уже изменена».
</p>
Конкретный способ реализации выбирается разработчиками СУБД, а в ряде случаев может настраиваться. Так, по умолчанию MS SQL использует блокировки, но 
(в версии 2005 и выше) при установке параметра READ_COMMITTED_SNAPSHOT базы данных переходит на стратегию версионности, Oracle исходно работает только 
по версионной схеме. В Informix можно предотвратить конфликты между читающими и пишущими транзакциями, установив параметр конфигурации USELASTCOMMITTED 
(начиная с версии 11.1), при этом читающая транзакция будет получать последние подтвержденные данные
<h4><b>Repeatable read (повторяемость чтения)</b></h4>
Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны. При этом никакая другая транзакция не может изменять 
данные, читаемые текущей транзакцией, пока та не окончена.
Блокировки в разделяющем режиме применяются ко всем данным, считываемым любой инструкцией транзакции, и сохраняются до её завершения. Это запрещает другим 
транзакциям изменять строки, которые были считаны незавершённой транзакцией. Однако другие транзакции могут вставлять новые строки, соответствующие условиям 
поиска инструкций, содержащихся в текущей транзакции. При повторном запуске инструкции текущей транзакцией будут извлечены новые строки, что приведёт к 
фантомному чтению. Учитывая то, что разделяющие блокировки сохраняются до завершения транзакции, а не снимаются в конце каждой инструкции, степень параллелизма 
ниже, чем при уровне изоляции READ COMMITTED. Поэтому пользоваться данным и более высокими уровнями транзакций без необходимости обычно не рекомендуется.   
<h4><b>Serializable (упорядочиваемость)</b></h4>
Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга, каждая выполняется так, как будто параллельных транзакций не существует. 
Только на этом уровне параллельные транзакции не подвержены эффекту «фантомного чтения». 

<hr>